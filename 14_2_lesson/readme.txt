### 14.2 5. Реализуем метод insert  5 из 8

# Задача 3
1. Реализовать классы
2. Использовать аннотации
3. Комментировать код
4. Использовать подходящие имена
5. Следовать TTD-подходу
6. Вести разработку по GitFlow


Как писать тест на функционал, который ты еще не знаешь.
Ты знаешь функционал, который закладывает заказчик, поэтому нужно отталкиваться от задачи.
Как код должен работать. Код должен работать от задания, а не от кода.


    src (через Python package)
        article.py
            class Article:
                """ класс для хранения статьи """
                article_id: int
                title: str
                content: str


                def __init__(self, title, content):
                    """ Конструктор для статьи """
                    self.title = title
                    self.content = content

    tests (Python package), с __init__.py
        test_init
    .gitignore
    pyproject.toml


## Шаги решения

Реализовать функционал класса для создания объектов.
Реализовать метод
insert
.
Написать тесты.
Отладить решение.
При написании кода важно:

использовать аннотации,
комментировать код,
использовать подходящие имена,
вести разработку по GitFlow.
Схема, на которой обозначено, из чего состоит класс:



### 14.2 Лучшие практики ООП --
### 14.2 14_2

Что такое «лучшие практики»
Важный этап работы любого разработчика — написание не только работоспособного кода, но также читаемого и оптимального. Уроки «Лучшие практики» предназначены для того, чтобы показать, как ведется разработка проекта, а также наглядно изучить разные подходы к разработке и зафиксировать для себя те правила, которыми руководствуется разработчик при работе над проектом.

Данный урок лучших практик посвящен отработке не только материалов уроков по ООП, которые вы успели пройти, но также работе с кодом, декомпозиции и оформлению репозитория.

Работа над задачей, в первую очередь, подразумевает понимание условий задачи и разбиение ее на более мелкие и понятные, то есть декомпозицию.

Далее при работе над задачей важно заложить правильную основу проекта: структуру, репозиторий, описать правила добавления файлов в индекс.

И только в последнюю очередь следует писать код. Для написания кода существуют разные подходы. В этом уроке мы будем использовать TDD.

На уроке
Вы познакомитесь с лучшими практиками, которые включают в себя:

Декомпозицию задачи. Это то, с чего стоит начинать работу над любым проектом или задачей, так как этот процесс позволит разбить входящую задачу на более мелкие и понятные задачи и к тому же позволит преобразовать входящую задачу от заказчика в понятный алгоритмический язык.
Настройку Git и следование GitFlow. Перед тем, как начинать что-либо делать с кодом, важно создать место, где будет храниться ваш проект и как вы будете следить за изменениями.
Настройку окружения. Это стандартный шаг для разработки, благодаря которому у любого, кто будет работать над проектом, будет возможность иметь актуальный список пакетов, который используется при решении задачи.
Создание структуры проекта. Позволяет сразу правильно заложить расположение файлов и папок в проекте, чтобы в них описывать код и логически разделить по назначению.
Использование аннотации. Подскажет корректное использование описанных функций и методов, что поможет допустить как можно меньше ошибок типов.
Использование docstring. Помогает читать код и понимать, для чего написать тот или иной функционал.
Тестирование кода. Это инструмент для отладки и проверки работоспособности кода.
























---------- * * * * ----------

### 14.2 14_2
### 2. Что такое декомпозиция задачи 2 из 8
Вы уже знакомы с этим материалом. Предлагаем повторить информацию — она пригодится вам при решении задачи урока.

Подход к задачам
В программировании при выполнении задачи не всегда бывает понятно, как ее решить. Поэтому задачу декомпозируют и смотрят на нее под иным углом.

## Декомпозиция — процесс разбиения сложной, казалось бы, невыполнимой задачи на набор из более маленьких понятных задач.

При этом процесс декомпозиции может быть рекурсивным (т. е. он может повторяться внутри самого себя), что часто помогает приходить к результату намного быстрее, чем обычный взгляд на проблему или задачу под широким углом обзора.

## Этапы декомпозиции
Разбейте задачу на шаги, которые на первый взгляд кажутся логичными для начала работы.
Все понятные шаги отложите в отдельный список как условно известные величины работы.
Все непонятные шаги рассмотрите вне контекста по отдельности так, чтобы шаги рядом имели минимальное влияние.
Каждый непонятный шаг воспринимайте как отдельную задачу и начинайте с п. 1.
Пример
Нужно реализовать класс для хранения данных о пользователе, который зарегистрировался по почте, Ф. И. О. и дате рождения, и добавить возможность отправки поздравления с днем рождения.

В первую очередь всегда обращайте внимание на то, какие условия заданы и что именно требуется реализовать по задаче.

Решение
Итерация 1

## Понятные шаги:

Создать новый проект.
Создать класс с полями: почта, имя, фамилия, отчество, дата рождения.
Непонятные шаги:

Регистрация.
Отправка письма.
Проверка даты рождения для отправки письма.
Разложим непонятные шаги:

Регистрация.
Заметим, что в задаче нет описания реализации механизма регистрации, значит, необходимо уточнить у постановщика задачи, нужен ли такой механизм или реализован ли он → задача ясна.

Отправка письма.
Создать метод класса, в который будет передаваться: сообщение, тема → задача ясна.

Отправить письмо → задача не ясна.

Проверка даты рождения для отправки письма.
Сделать метод для класса для проверки дат (заглушка) → задача ясна.

Получить текущую дату — день и месяц → задача ясна.

Сравнить поле из объекта пользователя с текущей датой из метода, полученного ранее → задача ясна.

## Итерация 2

Понятные шаги:

Создать новый проект.
Регистрация (постановщик задачи сказал, что функционал уже есть, значит, реализация не требуется).
Создать класс с полями: почта, имя, фамилия, отчество, дата рождения.
Проверка даты рождения для отправки письма.
Создать метод для отправки письма без самой отправки.
Непонятные шаги:

Отправка письма.
Разложим непонятные шаги.

Поиск в материалах лекций и скринкастов показал, что для отправки писем используется метод
send_mail → задача ясна.

Таким образом, задача раскладывается на набор понятных шагов, которые известно, как выполнять, или можно найти решение в документации/материалах.

### Шаги решения
Проанализировать требования.
Продумать архитектуру решения.
Сделать декомпозицию.


---------- * * * * ----------

### 14.2 14_2
### 4. Готовим рабочее окружение 4 из 8

Чтобы настроить рабочее окружение, следует создать репозиторий, выстроить работу по GitFlow и поставить нужные зависимости.

##Шаги решения
    Создать репозиторий и ветки.
    Установить зависимости.
    Создать структуру проекта.
##Результат
Вы можете посмотреть результат работы этого этапа по ссылке:

https://github.com/skypro-008/bp/tree/feature-2


## Решение по видео
1 создаем пустую папку
2 Добавляем VCS (GIT) - появляется ветка
3 Нужно создать виртуальное окружение и интерпретатор Prpject -> Python Interpretor (Poetry Envinronment), либо через консоль
Появляется файл -> pyproject.toml
4. Добавляем .gitignore (берем из интернета под Python)
5. Добавляем файл в индекс
6. Комитим commit
7. Нельзя комитить в мастер, поэтому нужно сделать ветку develop, но вся разработка будет сливаться в develop, поэтому делаем задачу feature_2 или другой номер.
8. Создаем структуру
    src (через Python package)
        article.py
            class Article:
                """ класс для хранения статьи """

                def __init__(self):
                    """ Конструктор для статьи """
                    pass

    tests (Python package), с __init__.py
        test_init
    .gitignore
    pyproject.toml

9. Добавляем пакет для написания тестов
cmd -> poetry add pytest
Поменялся pyproject.toml и добавился poetry.loc (указывает конкретные версии, которые мы используем). Его нужно закомитить, чтобы не потеряться в версии.
10. Обновляется список зависимостей и можно сделать еще один commit
commit -> добавляем зависимости (requirements)




---------- * * * * ----------
--



### 14.2 14_2
### 5. Реализуем метод insert  5 из 8

# Задача 3
1. Реализовать классы
2. Использовать аннотации
3. Комментировать код
4. Использовать подходящие имена
5. Следовать TTD-подходу
6. Вести разработку по GitFlow


Как писать тест на функционал, который ты еще не знаешь.
Ты знаешь функционал, который закладывает заказчик, поэтому нужно отталкиваться от задачи.
Как код должен работать. Код должен работать от задания, а не от кода.


    src (через Python package)
        article.py
            class Article:
            """ класс для хранения статьи """
            article_id: int
            title: str
            content: str

            # атрибут на уровне класса для хранения всех статей
            articles = dict()  # как хранить, чтобы быстро получать доступ, лучший вариант хранить в словаре

            def __init__(self, title, content):
                """ Конструктор для статьи """
                self.article_id = self.get_new_id()  # сразу ставим метод, чтобы получать ID
                self.title = title
                self.content = content


            #  нужен метод, который будет проходить по всем id искать последний и прибавлять 1
            def get_new_id(self) -> int:
                """ Метод для получения id следующей статьи """
                if len(self.articles) > 0:
                    # должен вернуться следующий id, поэтому мы берем max + 1
                    # когда артибут меняется на уровне класса, он меняется на всех объектах
                    return max(self.articles.keys()) + 1
                return 1

            #  номер id все также выводится 1, все потому, что articles мы нигде не начали заполнять.
            #  метод к добавлению
            #  создается новая статья, и статья добавляется в список articles
            @classmethod
            def insert(cls, title: str, content: str):
                """ метод для создания и добавления статьи """
                # режимы доступа. Можно вместо метода, использовать класс метод ( def insert(self, title: str, content: str): -> classmwthod )
                new_article = cls(title, content)
                # т.к. мы работаем с классом, то можно обратиться
                # мы обращаемся к словарю articles, в квадратных передаем новый id и присваиваем ему значение нового id
                cls.articles[new_article.article_id] = new_article
                return new_article


        if __name__ == "__main__":
            # после добавление классметода меняем Article('test1', 'test1') - > Article.insert('test1', 'test1')
            new_article_1 = Article.insert('test1', 'test1')
            print(new_article_1.article_id)

            new_article_2 = Article.insert('test2', 'test2')
            print(new_article_2.article_id)


    tests (Python package), с __init__.py
        test_insert.py
            import pytest
            from src.article import Article


            @pytest.fixture
            def one_article():
                """ Создаем фикстуру, куда передаем для теста значение """
                Article.articles = dict()  # очищаем список для тестов, чтобы обнулялся при добавлении новой статьи
                return Article.insert('test', 'test')


            @pytest.fixture
            def two_articles():
                Article.articles = dict()
                Article.insert('test', 'test')  # копипаст с one_article
                return Article.insert('test2', 'test2')



            def test_insert(one_article):
                """ тест для провеврки, что количество статей равно единице """
                assert len(Article.articles) == 1


            def test_article_id(one_article):
                """ Тест на проверку установки ID статьи """
                assert one_article.article_id == 1


            def test_increase_id(two_articles):
                """ Тест на проверку увеличения ID статьи """
                assert two_articles.article_id == 2


            def test_increase_articles_count(two_articles):
                """ Тест на увеличение списка статей """
                assert len(Article.articles) == 2

    .gitignore
    pyproject.toml


## Шаги решения

Реализовать функционал класса для создания объектов.
Реализовать метод
insert
.
Написать тесты.
Отладить решение.
При написании кода важно:

использовать аннотации,
комментировать код,
использовать подходящие имена,
вести разработку по GitFlow.
Схема, на которой обозначено, из чего состоит класс:


class Company:
    """ Класс представляет компанию с сотрудниками. """

    def __init__(self) -> None:
        self.employees: list[Employee] = []

    def add_employee(self, employee: Employee) -> None:  # -> None - аннотация
        """ Добавить сотрудника в список сотрудников """
        self.yemployyes.append(employee)

    def find_employee(self, role: Role) -> list[Employee]:
        """ Найти всех сотрудников с определенной ролью в списке сотрудников """
        return [employee for employee in self.employees if employee.role is role]

Результат
Вы можете посмотреть результат работы этого этапа по ссылкам:

https://github.com/skypro-008/bp/commit/f494
https://github.com/skypro-008/bp/commit/0476








---------- * * * * ----------





### 14.2 14_2
### 6. Реализуем метод search через TDD 6 из 8

Шаги решения

Написать тесты.
Реализовать метод search.
Отладить решение.
При написании кода важно:

использовать аннотации,
комментировать код,
использовать подходящие имена,
вести разработку по GitFlow,
следовать TDD-подходу.

Результат
Вы можете посмотреть результат работы этого этапа по ссылке:

https://github.com/skypro-008/bp/tree/feature-3


## папки и файлы урока

    src (через Python package)
        article.py
            class Article:
            """ класс для хранения статьи """
            article_id: int
            title: str
            content: str

            # атрибут на уровне класса для хранения всех статей
            articles = dict()  # как хранить, чтобы быстро получать доступ, лучший вариант хранить в словаре

            def __init__(self, title, content):
                """ Конструктор для статьи """
                self.article_id = self.get_new_id()  # сразу ставим метод, чтобы получать ID
                self.title = title
                self.content = content


            #  нужен метод, который будет проходить по всем id искать последний и прибавлять 1
            def get_new_id(self) -> int:
                """ Метод для получения id следующей статьи """
                if len(self.articles) > 0:
                    # должен вернуться следующий id, поэтому мы берем max + 1
                    # когда артибут меняется на уровне класса, он меняется на всех объектах
                    return max(self.articles.keys()) + 1
                return 1

            #  номер id все также выводится 1, все потому, что articles мы нигде не начали заполнять.
            #  метод к добавлению
            #  создается новая статья, и статья добавляется в список articles
            @classmethod
            def insert(cls, title: str, content: str):
                """ метод для создания и добавления статьи """
                # режимы доступа. Можно вместо метода, использовать класс метод ( def insert(self, title: str, content: str): -> classmwthod )
                new_article = cls(title, content)
                # т.к. мы работаем с классом, то можно обратиться
                # мы обращаемся к словарю articles, в квадратных передаем новый id и присваиваем ему значение нового id
                cls.articles[new_article.article_id] = new_article
                return new_article


            @classmethod
            def search(cls, article_id):
                """ Метод для поиска статьи по ID """
                #  Если мы пробуем метод "Утрированный путь", то мы можем в методе задать сразу значение
                #  чтобы получить ожидаемый результат теста, а потом уже оформить корректный return
                #  Утрированно -> return self.Article('1', '2') -> получаем результат проверки: '1' != 'test3'
                # return cls('test3', 'test3')
                return cls.articles[article_id]

            # потом переделываем на классметод
            # def search(self):
            #     """ Метод для поиска статьи по ID """
            #     #  Если мы пробуем метод "Утрированный путь", то мы можем в методе задать сразу значение
            #     #  чтобы получить ожидаемый результат теста, а потом уже оформить корректный return
            #     #  Утрированно -> return Article('1', '2') -> получаем результат проверки: '1' != 'test3'
            #     return  self.Article('1', '2')


        if __name__ == "__main__":
            # после добавление классметода меняем Article('test1', 'test1') - > Article.insert('test1', 'test1')
            new_article_1 = Article.insert('test1', 'test1')
            print(new_article_1.article_id)

            new_article_2 = Article.insert('test2', 'test2')
            print(new_article_2.article_id)


    tests (Python package), с __init__.py
        test_insert.py
            import pytest
            from src.article import Article


            @pytest.fixture
            def one_article():
                """ Создаем фикстуру, куда передаем для теста значение """
                Article.articles = dict()  # очищаем список для тестов, чтобы обнулялся при добавлении новой статьи
                return Article.insert('test', 'test')


            @pytest.fixture
            def two_articles():
                Article.articles = dict()
                Article.insert('test', 'test')  # копипаст с one_article
                return Article.insert('test2', 'test2')



            def test_insert(one_article):
                """ тест для провеврки, что количество статей равно единице """
                assert len(Article.articles) == 1


            def test_article_id(one_article):
                """ Тест на проверку установки ID статьи """
                assert one_article.article_id == 1


            def test_increase_id(two_articles):
                """ Тест на проверку увеличения ID статьи """
                assert two_articles.article_id == 2


            def test_increase_articles_count(two_articles):
                """ Тест на увеличение списка статей """
                assert len(Article.articles) == 2

        test_search.py # также добавляем метод search в article.py
            import pytest
            from src.article import Article



            @pytest.fixture
            def list_articles():
                """ наполняем наш список статьями
                Потому что мы при тестировании будем проверять, сработал ли поиск по ID
                """
                Article.articles = dict()  #  важно зачистить список, чтобы тест проходил чисто, т.к. в других тестах могут передваться другие значения в словарь
                Article.insert('test1', 'test1')  # копипаст с one_article
                Article.insert('test2', 'test2')  # копипаст с one_article
                Article.insert('test3', 'test3')  # копипаст с one_article
                Article.insert('test4', 'test4')  # копипаст с one_article
                Article.insert('test5', 'test5')  # return тут можно не ставить


            def test_search_3(list_articles):
                """ передаем статью для поиска и проверяем поиск
                Тестирование поиска статьи по ID
                но сравниваем не ID & ID, а сравниваем ID и заголовок передаваемой статьи
                """
                searchable_articles = Article.search(3)
                assert searchable_articles.title == 'test3'


            def test_search_4(list_articles):
                """ передаем статью для поиска и проверяем поиск
                Тестирование поиска статьи по ID
                но сравниваем не ID & ID, а сравниваем ID и заголовок передаваемой статьи
                """
                searchable_articles = Article.search(4)
                assert searchable_articles.title == 'test4'


    .gitignore
    pyproject.toml





---------- * * * * ----------


## 14.2 14_2
### Итоги урока

Теперь вы знаете, что при работе над задачей необходимо учитывать следующие ключевые моменты:
Создать Git-репозиторий сразу.
Настроить виртуальное окружение.
Ставить зависимости, особенно группы dev (тесты, линтеры).
Декомпозировать задачу, написать интерфейсы.
Написать тесты.
Делать код читабельным с помощью:
структуры,
декомпозиции,
именования,
аннотации,
docstring,
комментариев.



### Материалы урока

### 14.2 14_2
### 8. Материалы 8 из 8
Ссылка на файл .gitignore:

https://github.com/github/gitignore/

Результаты работы этапов:

«Декомпозируем задачу»:
https://github.com/skypro-008/bp/tree/develop

«Готовим рабочее окружение»:
https://github.com/skypro-008/bp/tree/feature-2

«Пишем код»:
https://github.com/skypro-008/bp/tree/feature-3
















